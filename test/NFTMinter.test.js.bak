// Load dependencies
const { expect } = require('chai');

// Import utilities from Test Helpers
const { BN, expectEvent, expectRevert } = require('@openzeppelin/test-helpers');
const { deployments, getNamedAccounts, ethers } = require('hardhat');
const ConsoleProgressBar = require('console-progress-bar');

const toBN = ethers.BigNumber.from;

describe('Minting tests', () => {
  let deployer;
  let random;
  let random2;
  let unlocker;
  let holder;
  let spender;
  let allowancesigner;
  let holder2;
  let holder3;
  let holder4;
  const ADDRESS_ZERO = ethers.constants.AddressZero;
  const mybaseURI = "fake_URI/"; //we deploy with fake uri not to disclose actual base uri 
  const unrevURI = "unrev_URI/";
 
  const provider = ethers.provider;
  const { hexlify, toUtf8Bytes } = ethers.utils;

async function sign(spender, tokenId, nonce, deadline, signer) {
  //inspired by @dievardump's implementation
  const typedData = {
      types: {
          Permit: [
              { name: 'spender', type: 'address' },
              { name: 'tokenId', type: 'uint256' },
              { name: 'nonce', type: 'uint256' },
              { name: 'deadline', type: 'uint256' },
          ],
      },
      primaryType: 'Permit',
      domain: {
          name: await nftContract.name(),
          version: '1',
          chainId: chainId,
          verifyingContract: nftContract.address,
      },
      message: {
          spender,
          tokenId,
          nonce,
          deadline,
      },
  };

  const signature = await signer._signTypedData(
      typedData.domain,
      { Permit: typedData.types.Permit },
      typedData.message,
  );

  return signature;
}

async function signAllowance(account, mintQty, allowanceId, price, signerAccount = allowancesigner) {
  const idBN = toBN(allowanceId).shl(64);
  const idAndQty = idBN.add(mintQty);
  const idAndQtyShifted = idAndQty.shl(128);
  const nonce = idAndQtyShifted.add(price);
  const message = await minterContr.createMessage(account, nonce);

  //const formattedMessage = hexlify(toUtf8Bytes(message));
  const formattedMessage = hexlify(message);
  const addr = signerAccount.address.toLowerCase();

  /*
  const signature = await signerAccount.signMessage(
      ethers.utils.arrayify(message),
  );
  */

  const signature = await provider.send('eth_sign', [addr, formattedMessage]);

  return { nonce, signature };
}

  beforeEach(async () => {
      [deployer, random, random2, unlocker, holder, spender, allowancesigner, holder2, holder3, holder4] = await ethers.getSigners();

      // get chainId
      chainId = await ethers.provider.getNetwork().then((n) => n.chainId);

      const NFT = await ethers.getContractFactory('ADG1', deployer);
      nftContract = await NFT.deploy(mybaseURI, unrevURI);

      // deploy gen0
      const NFTGen0 = await ethers.getContractFactory('testGen0', deployer);
      nftGen0 = await NFTGen0.deploy(mybaseURI, unrevURI);

      const Minter = await ethers.getContractFactory('NFTminter', deployer);
      minterContr = await Minter.deploy(nftContract.address, nftGen0.address);

      await minterContr.connect(deployer).setMaxPerMint(3);
      await minterContr.connect(deployer).switchPublicSale();
      await minterContr.connect(deployer).switchPresale();
      await nftContract.connect(deployer).setMinter(minterContr.address); 
      await minterContr.connect(deployer).setAllowancesSigner(await allowancesigner.getAddress());

  });

  describe('Deployment', async function () {
    it('deploys', async function () {
        expect(nftContract.address).to.not.equal("");
    });
    it('deploys with correct base URI', async function () {
      const mintQty = 1;
      let mintCost = await minterContr.publicSalePrice();
      await minterContr.connect(random).publicOrder(await random.getAddress(), mintQty, {value: mintCost});
      expect(await nftContract.tokenURI((await nftContract.nextTokenIndex()).sub(1))).to.include(unrevURI);
    });
    it('deploys with 0 tokens', async function () {
      expect(await nftContract.totalSupply()).to.equal(0);
    });
  });

  /*  ====== ====== ====== ====== ====== ======
    *   
    *   PRESALE MINTING TESTS
    * 
    * ====== ====== ====== ====== ======  ====== */

  describe('Presale minting', async function () {
    it('can mint token with a signature', async function () {

      const mintQty = 3;
      const itemPrice = await minterContr.presalePrice();

      const { nonce: nonce, signature: allowance } = await signAllowance(
          await random.getAddress(),
          mintQty,
          Math.floor(Math.random() * 1000 * (await provider.getBlockNumber())), //some random allowance id
          itemPrice //price
      );
        
      let totalCost = ethers.BigNumber.from(mintQty).mul(itemPrice);
      await minterContr.connect(random).presaleOrder(await random.getAddress(), nonce, allowance, {value: totalCost});

      /*
      console.log("QTY detection ", await minterContr.testedQty());
      console.log("PRICE detection test price ", await minterContr.testedPrice());
      console.log("PRICE detection actu price ", await minterContr.presalePrice());
      */

      expect(
          await nftContract.balanceOf(await random.getAddress()),
      ).to.be.equal(mintQty);
  });

  it('can free mint token with a signature', async function () {

    const mintQty = 1;
    const itemPrice = ethers.BigNumber.from(0);

    const { nonce: nonce, signature: allowance } = await signAllowance(
        await random.getAddress(),
        mintQty,
        Math.floor(Math.random() * 1000 * (await provider.getBlockNumber())), //some random allowance id
        itemPrice //price
    );
      
    let totalCost = ethers.BigNumber.from(mintQty).mul(itemPrice);
    await minterContr.connect(random).presaleOrder(await random.getAddress(), nonce, allowance, {value: totalCost});

    expect(
        await nftContract.balanceOf(await random.getAddress()),
    ).to.be.equal(mintQty);
});
  
  it('can mint token with an allowance made for other person that was not used yet to other person wallet', async function () {

      const mintQty = 1;
      const itemPrice = await minterContr.presalePrice();

      const { nonce: nonce, signature: allowance } = await signAllowance(
          await random.getAddress(),
          mintQty,
          Math.floor(Math.random() * 1000 * (await provider.getBlockNumber())), //some random allowance id
          itemPrice 
      );
        
      let totalCost = ethers.BigNumber.from(mintQty).mul(itemPrice);
      await minterContr.connect(random2).presaleOrder(await random.getAddress(), nonce, allowance, {value: totalCost});

      expect(
          await nftContract.balanceOf(await random.getAddress()),
      ).to.be.equal(mintQty);
  });
   
  it('can mint several quotas with same capacity but diff nonce', async function () {

    const mintQty = 1;
    const quotas = 5;
    const itemPrice = await minterContr.presalePrice();

    for (let i=0; i<quotas; i++) {
      const { nonce: nonce, signature: allowance } = await signAllowance(
          await random.getAddress(),
          mintQty,
          Math.floor(Math.random() * 1000), //some random allowance id
          itemPrice 
      );

      let totalCost = ethers.BigNumber.from(mintQty).mul(itemPrice);
      await minterContr.connect(random).presaleOrder(await random.getAddress(), nonce, allowance, {value: totalCost});

    }
    expect(
        await nftContract.balanceOf(await random.getAddress()),
    ).to.be.equal(mintQty*quotas);
  });

  it('cannot reuse signature', async function () {

    const mintQty = 1;
    const itemPrice = await minterContr.presalePrice();

    const allowId = Math.floor(Math.random() * 1000 * (await provider.getBlockNumber()));
      const { nonce: nonce, signature: allowance } = await signAllowance(
          await random.getAddress(),
          mintQty,
          allowId,
          itemPrice 
      );

      let totalCost = ethers.BigNumber.from(mintQty).mul(itemPrice);
      await minterContr.connect(random).presaleOrder(await random.getAddress(), nonce, allowance, {value: totalCost});

    await expect(
      minterContr.connect(random).presaleOrder(await random.getAddress(), nonce, allowance, {value: totalCost}),
    ).to.be.revertedWith('!ALREADY_USED!');
  });

  it('cannot mint to yourself with other persons allowance', async function () {

    const mintQty = 1;
    const itemPrice = await minterContr.presalePrice();

    const allowId = Math.floor(Math.random() * 1000 * (await provider.getBlockNumber()));
      const { nonce: nonce, signature: allowance } = await signAllowance(
          await random.getAddress(),
          mintQty,
          allowId,
          itemPrice 
      );

      let totalCost = ethers.BigNumber.from(mintQty).mul(itemPrice);
    await expect(
      minterContr.connect(random2).presaleOrder(await random2.getAddress(), nonce, allowance, {value: totalCost}),
    ).to.be.revertedWith('!INVALID_SIGNATURE!');
  });

  it('cannot mint with signature by wrong signer', async function () {

    const mintQty = 1;
    const itemPrice = await minterContr.presalePrice();

      const { nonce: nonce, signature: allowance } = await signAllowance(
          await random.getAddress(),
          mintQty,
          Math.floor(Math.random() * 1000), 
          itemPrice,
          random2
      );

      let totalCost = ethers.BigNumber.from(mintQty).mul(itemPrice);
    await expect(
      minterContr.connect(random).presaleOrder(await random.getAddress(), nonce, allowance, {value: totalCost}),
    ).to.be.revertedWith('!INVALID_SIGNATURE!');
  });

  it('cannot mint with previously valid signature when we revoked everyhting by changing signer in the contract', async function () {
    
    const mintQty = 1;
    const itemPrice = await minterContr.presalePrice();

    const { nonce: nonce, signature: allowance } = await signAllowance(
          await random.getAddress(),
          mintQty,
          Math.floor(Math.random() * 1000),
          itemPrice  
    );
    
    let totalCost = ethers.BigNumber.from(mintQty).mul(itemPrice);
    await minterContr.connect(deployer).setAllowancesSigner(random.address);
    
    await expect(
      minterContr.connect(random).presaleOrder(await random.getAddress(), nonce, allowance, {value: totalCost}),
    ).to.be.revertedWith('!INVALID_SIGNATURE!');
  });

  it('non owner can not change signer', async function () {
    await expect(
      minterContr.connect(random).setAllowancesSigner(random.address),
    ).to.be.revertedWith('Ownable: caller is not the owner');
  });

  it('cannot mint with increased nonce', async function () {

    const mintQty = ethers.BigNumber.from(1);
    const itemPrice = await minterContr.presalePrice();

    const { nonce: nonce, signature: allowance } = await signAllowance(
          await random.getAddress(),
          mintQty,
          Math.floor(Math.random() * 1000), 
          itemPrice 
    );

    const nonce2 = nonce.add(2);

    let totalCost = ethers.BigNumber.from(mintQty.add(2)).mul(itemPrice);

    await expect(
      minterContr.connect(random).presaleOrder(await random.getAddress(), nonce2, allowance, {value: totalCost}),
    ).to.be.revertedWith('!INVALID_SIGNATURE!');
  });

  it('cannot manipulate signature', async function () {

    const mintQty = 1;
    const itemPrice = await minterContr.presalePrice();

      let { nonce: nonce, signature: allowance } = await signAllowance(
          await random.getAddress(),
          mintQty,
          Math.floor(Math.random() * 1000), //345,
          itemPrice 
      );

      allowance =
            '0x45eacf01' + allowance.substr(-(allowance.length - 10));

      let totalCost = ethers.BigNumber.from(mintQty).mul(itemPrice);
    await expect(
      minterContr.connect(random).presaleOrder(await random.getAddress(), nonce, allowance, {value: totalCost}),
    ).to.be.reverted;
  }); 

  it('can not order before presale started', async function () {
    let tx = await minterContr.connect(deployer).switchPresale();
    await tx.wait();

    expect((await minterContr.presaleActive())).to.be.false;

    const mintQty = 1;
    const itemPrice = ethers.BigNumber.from(0);
    
    const { nonce: nonce, signature: allowance } = await signAllowance(
          await random.getAddress(),
          mintQty,
          Math.floor(Math.random() * 1000 * (await provider.getBlockNumber())), //some random allowance id
          itemPrice 
    );
        
    let totalCost = ethers.BigNumber.from(mintQty).mul(itemPrice);

    await expect (
      minterContr.connect(random).presaleOrder(await random.getAddress(), nonce, allowance, {value: totalCost}),
    ).to.be.revertedWith('Presale not active');          
  });

  //can not mint with wrong price
  it('cannot mint with incorrect price', async function () {

    const mintQty = 2;
    const itemPrice = await minterContr.presalePrice();

      const { nonce: nonce, signature: allowance } = await signAllowance(
          await random.getAddress(),
          mintQty,
          Math.floor(Math.random() * 1000), 
          itemPrice
      );

      let totalCost = ethers.BigNumber.from(mintQty).mul(itemPrice.sub(10000000000));
    await expect(
      minterContr.connect(random).presaleOrder(await random.getAddress(), nonce, allowance, {value: totalCost}),
    ).to.be.revertedWith('Minter: Not Enough Eth');
  });

});

/*  ====== ====== ====== ====== ====== ======
    *   
    *   GEN0 Free Mints TESTS
    * 
    * ====== ====== ====== ====== ======  ====== */

describe('Gen0 free mints tests', async function () {

  beforeEach(async () => {  
    let randomAmount = (Math.floor(Math.random() * 10)) + 1;    
    let txPrelMint = await nftGen0.connect(random).mint(await random.getAddress(), randomAmount);
    await txPrelMint.wait();

    randomAmount = (Math.floor(Math.random() * 10)) + 3; // holder has at least 3
    txPrelMint = await nftGen0.connect(holder).mint(await holder.getAddress(), randomAmount);
    await txPrelMint.wait();

    randomAmount = (Math.floor(Math.random() * 10)) + 1;
    txPrelMint = await nftGen0.connect(holder2).mint(await holder2.getAddress(), randomAmount);
    await txPrelMint.wait();
    
    randomAmount = (Math.floor(Math.random() * 10)) + 1;
    txPrelMint = await nftGen0.connect(holder3).mint(await holder3.getAddress(), randomAmount);
    await txPrelMint.wait();

    randomAmount = (Math.floor(Math.random() * 10)) + 1;
    txPrelMint = await nftGen0.connect(holder4).mint(await holder4.getAddress(), randomAmount);
    await txPrelMint.wait();

    randomAmount = (Math.floor(Math.random() * 10)) + 1;
    txPrelMint = await nftGen0.connect(holder3).mint(await holder3.getAddress(), randomAmount);
    await txPrelMint.wait();
    
    //console.log((await nftGen0.totalSupply()).toString());
  });

  it('can free mint for several gen0 tokens and it mints the correct amount', async function () {

    expect(await nftContract.totalSupply()).to.equal(0);
    expect(await nftContract.balanceOf(await holder.getAddress())).to.equal(0);

    let tokenIds = await nftGen0.tokensOfOwner(await holder.getAddress());
    //console.log(tokenIds, "length: ", tokenIds.length);

    let tx2 = await minterContr.connect(holder).sgFreeMint(tokenIds);
    await tx2.wait();
        
    expect(await nftContract.totalSupply()).to.equal(tokenIds.length);
    expect(await nftContract.balanceOf(await holder.getAddress())).to.equal(tokenIds.length);
  }); 

  it('can free mint for 1 gen0 token', async function () {

    expect(await nftContract.totalSupply()).to.equal(0);
    expect(await nftContract.balanceOf(await holder.getAddress())).to.equal(0);

    let tokenIds = await nftGen0.tokensOfOwner(await holder.getAddress());
    let length =  tokenIds.length;
    randomIndex = (Math.floor(Math.random() * length));
    randomId = tokenIds[randomIndex];

    let tx2 = await minterContr.connect(holder).sgFreeMint([randomId]);
    await tx2.wait();
        
    expect(await nftContract.totalSupply()).to.equal(1);
    expect(await nftContract.balanceOf(await holder.getAddress())).to.equal(1);
  }); 

  it('can free mint for mixed array of owned and non-owned gen0 tokens', async function () {

    expect(await nftContract.totalSupply()).to.equal(0);
    expect(await nftContract.balanceOf(await holder3.getAddress())).to.equal(0);

    let tokenIds = await nftGen0.tokensOfOwner(await holder3.getAddress());
    let tokenIds2 = await nftGen0.tokensOfOwner(await holder.getAddress());

    let tokenIds3 = tokenIds.concat(tokenIds2);
    tokenIds3 = tokenIds3.sort();
    //console.log(tokenIds3, "length: ", tokenIds3.length);

    let tx2 = await minterContr.connect(holder3).sgFreeMint(tokenIds3);
    await tx2.wait();
        
    expect(await nftContract.totalSupply()).to.equal(tokenIds.length);
    expect(await nftContract.balanceOf(await holder3.getAddress())).to.equal(tokenIds.length);
  }); 

  it('can not free mint for non-owned gen0 tokens', async function () {

    expect(await nftContract.totalSupply()).to.equal(0);
    expect(await nftContract.balanceOf(await holder.getAddress())).to.equal(0);

    let tokenIds = await nftGen0.tokensOfOwner(await holder.getAddress());
    //console.log(tokenIds, "length: ", tokenIds.length);

    await expect (
      minterContr.connect(holder2).sgFreeMint(tokenIds),
    ).to.be.revertedWith('CAN_NOT_MINT_0');
    
  }); 

  it('can not free mint for the same gen0 tokens twice', async function () {
    expect(await nftContract.totalSupply()).to.equal(0);
    expect(await nftContract.balanceOf(await holder.getAddress())).to.equal(0);

    let tokenIds = await nftGen0.tokensOfOwner(await holder.getAddress());
    //console.log(tokenIds, "length: ", tokenIds.length);

    let tx2 = await minterContr.connect(holder).sgFreeMint(tokenIds);
    await tx2.wait();
        
    //mint successfull
    expect(await nftContract.totalSupply()).to.equal(tokenIds.length);
    expect(await nftContract.balanceOf(await holder.getAddress())).to.equal(tokenIds.length);

    //but not twice
    await expect (
      minterContr.connect(holder).sgFreeMint(tokenIds),
    ).to.be.revertedWith('CAN_NOT_MINT_0');
  });

  it('can free mint for 1 gen0 token', async function () {
    expect(await nftContract.totalSupply()).to.equal(0);
    expect(await nftContract.balanceOf(await holder.getAddress())).to.equal(0);

    let tokenIds = await nftGen0.tokensOfOwner(await holder.getAddress());
    let length =  tokenIds.length;
    randomIndex = (Math.floor(Math.random() * length));
    randomId = tokenIds[randomIndex];

    let tx2 = await minterContr.connect(holder).sgFreeMint([randomId]);
    await tx2.wait();
        
    // we successfully minted for 1 token
    expect(await nftContract.totalSupply()).to.equal(1);
    expect(await nftContract.balanceOf(await holder.getAddress())).to.equal(1);

    // then we try to mint for the rest
    tx2 = await minterContr.connect(holder).sgFreeMint(tokenIds);
    await tx2.wait();

    // ensure we successfully minted the rest after minting 1
    expect(await nftContract.totalSupply()).to.equal(tokenIds.length);
    expect(await nftContract.balanceOf(await holder.getAddress())).to.equal(tokenIds.length);
  }); 

  // can be commented for speed

  /*
  it('if minting has failed because of >MaxItems, gen0 tokens are not marked as claimed', async function () {

    expect(await nftContract.totalSupply()).to.equal(0);
    expect(await nftContract.balanceOf(await holder.getAddress())).to.equal(0);

    let tokenIds = await nftGen0.tokensOfOwner(await holder.getAddress());
    //console.log(tokenIds, "length: ", tokenIds.length);

    console.log("Minting full supply: ");

    //mint 5554 gen1's
    const consoleProgressBar = new ConsoleProgressBar({ maxValue: 1851 });

    for (let i=0; i<1851; i++) {
      const mintQty = 3;
      let totalCost = ethers.BigNumber.from(mintQty).mul(await minterContr.publicSalePrice());
      let tx = await minterContr.connect(random).publicOrder(await random.getAddress(), mintQty, {value: totalCost});
      await tx.wait();
      consoleProgressBar.addValue(1);
    }

    expect(await nftContract.totalSupply()).to.equal(5553);

    //trying to mint more tokens should revert with >MaxSupply
    await expect(
      minterContr.connect(holder).sgFreeMint(tokenIds),
    ).to.be.revertedWith(">MaxSupply");
    
    for (let i=0; i<tokenIds.length; i++) {
      expect(await minterContr.claimed(tokenIds[i])).to.be.false;
    }

    expect(await nftContract.balanceOf(await holder.getAddress())).to.equal(0);

  }); 
  */

  it('can not re-enter minting and mint again', async function () {

    const Attacker = await ethers.getContractFactory('reentAttacker', deployer);
    attacker = await Attacker.deploy();

    expect(await nftContract.totalSupply()).to.equal(0);
    expect(await nftContract.balanceOf(attacker.address)).to.equal(0);


    let tokenIds = await nftGen0.tokensOfOwner(await holder.getAddress());
    let length =  tokenIds.length;
    randomIndex = (Math.floor(Math.random() * length));
    randomId = tokenIds[randomIndex];

    let tx = await
      nftGen0.connect(holder)["safeTransferFrom(address,address,uint256)"](
        await holder.getAddress(), await attacker.address, randomId
      );
    await tx.wait();

    expect(await nftGen0.balanceOf(attacker.address)).to.equal(1);

    //setup attacker
    let txA = await attacker.connect(deployer).setTarget(minterContr.address);
    await txA.wait();

    txA = await attacker.connect(deployer).setTokenIds([randomId]);
    await txA.wait();

    txA = await attacker.connect(deployer).switchAttack();
    await txA.wait();

    await expect (
      attacker.connect(deployer).tryAttack(),
    ).to.be.revertedWith("CAN_NOT_MINT_0");   

    expect(await nftContract.balanceOf(attacker.address)).to.equal(0);    

    /*
    txB = await attacker.connect(deployer).tryAttack();
    await txB.wait();
    expect(await nftContract.balanceOf(attacker.address)).to.equal(3);
    */
     
  });

});

/*  ====== ====== ====== ====== ====== ======
    *   
    *   PUBLIC SALE TESTS
    * 
    * ====== ====== ====== ====== ======  ====== */

describe('Public sale tests', async function () {

  it('can order to self', async function () {

    const mintQty = 1;
    let totalCost = ethers.BigNumber.from(mintQty).mul(await minterContr.publicSalePrice());

    expect(await nftContract.totalSupply()).to.equal(0);
    expect(await nftContract.balanceOf(await random.getAddress())).to.equal(0);

    await minterContr.connect(random).publicOrder(await random.getAddress(), mintQty, {value: totalCost});
        
    expect(await nftContract.totalSupply()).to.equal(mintQty);
    expect(await nftContract.balanceOf(await random.getAddress())).to.equal(mintQty);
  }); 

  it('can order to another person', async function () {

    const mintQty = 1;
    let totalCost = ethers.BigNumber.from(mintQty).mul(await minterContr.publicSalePrice());

    expect(await nftContract.totalSupply()).to.equal(0);
    expect(await nftContract.balanceOf(await random2.getAddress())).to.equal(0);

    await minterContr.connect(random).publicOrder(await random2.getAddress(), mintQty, {value: totalCost});
        
    expect(await nftContract.totalSupply()).to.equal(mintQty);
    expect(await nftContract.balanceOf(await random2.getAddress())).to.equal(mintQty);
  });

  it('can not order before sale', async function () {
    let tx = await minterContr.connect(deployer).switchPublicSale();
    await tx.wait();

    expect((await minterContr.publicSaleActive())).to.be.false;

    const mintQty = 1;
    let totalCost = ethers.BigNumber.from(mintQty).mul(await minterContr.publicSalePrice());

    await expect (
      minterContr.connect(random).publicOrder(await random2.getAddress(), mintQty, {value: totalCost}),
    ).to.be.revertedWith('Public sale not active');          
  });


  it('can not order more than max', async function () {

    const mintQty = (await minterContr.maxPerMint()).add(1);
    let totalCost = ethers.BigNumber.from(mintQty).mul(await minterContr.publicSalePrice());

    await expect (
      minterContr.connect(random).publicOrder(await random2.getAddress(), mintQty, {value: totalCost}),
    ).to.be.revertedWith('>Max per mint');          
  });

  it('can not order with low eth', async function () {
  
    const mintQty = (await minterContr.maxPerMint());
    let totalCost = ethers.BigNumber.from(mintQty).mul(await minterContr.publicSalePrice());
    let lowPayment = totalCost.sub(10000)

    await expect (
      minterContr.connect(random).publicOrder(await random2.getAddress(), mintQty, {value: lowPayment}),
    ).to.be.revertedWith('Minter: Not Enough Eth');          
  });

});

/*  ====== ====== ====== ====== ====== ======
    *   
    *   ADMIN FUNCTIONS TESTS
    * 
    * ====== ====== ====== ====== ======  ====== */

describe('Admin functions tests', async function () {

  it('can AdminMint', async function () {
    const mintQty = 1;
    expect(await nftContract.totalSupply()).to.equal(0);
    await minterContr.connect(deployer).adminMint(await random.getAddress(), mintQty);
    expect(await nftContract.totalSupply()).to.equal(mintQty);
    expect(await nftContract.balanceOf(await random.getAddress())).to.equal(mintQty);
  });

  it('can not adminMint if not admin: test onlyOwner function', async function () {
    const mintQty = 1;
    await expect(
        minterContr.connect(random).adminMint(await random.getAddress(), mintQty),
    ).to.be.revertedWith('Ownable: caller is not the owner');
  });

  it('can change Max Per Mint', async function () {

    let oldMPM = await minterContr.maxPerMint();
    
    let newMPMExp = 5;
    let tx = await minterContr.connect(deployer).setMaxPerMint(newMPMExp);
    await tx.wait();

    let newMPMSet = await minterContr.maxPerMint();
    
    expect(newMPMSet).to.equal(newMPMExp).and.to.not.equal(oldMPM);
  }); 

  it('can not set MPM if not admin: test onlyOwner function', async function () {
    await expect(
        minterContr.connect(random).setMaxPerMint(234234234),
    ).to.be.revertedWith('Ownable: caller is not the owner');
  });

  it('can change public sale price', async function () {

    let oldVal = await minterContr.publicSalePrice();
    
    let newValExp = 30000000000;
    let tx = await minterContr.connect(deployer).setPublicSalePrice(newValExp);
    await tx.wait();

    let newValSet = await minterContr.publicSalePrice();
    
    expect(newValSet).to.equal(newValExp).and.to.not.equal(oldVal);
  });

  it('can not set public sale price if not admin: test onlyOwner function', async function () {
    await expect(
        minterContr.connect(random).setPublicSalePrice(234234234),
    ).to.be.revertedWith('Ownable: caller is not the owner');
  });

  it('can change presale price', async function () {

    let oldVal = await minterContr.presalePrice();
    
    let newValExp = 30000000000;
    let tx = await minterContr.connect(deployer).setPresalePrice(newValExp);
    await tx.wait();

    let newValSet = await minterContr.presalePrice();
    
    expect(newValSet).to.equal(newValExp).and.to.not.equal(oldVal);
  });

  it('can not set presale price if not admin: test onlyOwner function', async function () {
    await expect(
        minterContr.connect(random).setPresalePrice(234234234),
    ).to.be.revertedWith('Ownable: caller is not the owner');
  });

  it('can not set NFT Contr if not admin: test onlyOwner function', async function () {
    await expect(
        minterContr.connect(random).setNFTContract(random2.getAddress()),
    ).to.be.revertedWith('Ownable: caller is not the owner');
  });

  it('can not set Allowances Signer if not admin: test onlyOwner function', async function () {
    await expect(
        minterContr.connect(random).setAllowancesSigner(random2.getAddress()),
    ).to.be.revertedWith('Ownable: caller is not the owner');
  });

  it('can not switch presale state if not admin: test onlyOwner function', async function () {
    await expect(
        minterContr.connect(random).switchPresale(),
    ).to.be.revertedWith('Ownable: caller is not the owner');
  });

  it('can not switch public sale state if not admin: test onlyOwner function', async function () {
    await expect(
        minterContr.connect(random).switchPublicSale(),
    ).to.be.revertedWith('Ownable: caller is not the owner');
  });

});


/*  ====== ====== ====== ====== ====== ======
*   
*   WITHDRAWALS TESTS
* 
* ====== ====== ====== ====== ======  ====== */

describe('Withdrawals tests', async function () {
 
  it('can not withdraw if not admin', async function () {
    await expect(
        minterContr.connect(random).withdraw(100000),
    ).to.be.revertedWith('Ownable: caller is not the owner');
  });

  it('can withdraw', async function () {
    let amt = toBN(10).pow(17); //0.1 eth

    const mintQty = 3;          
    let totalCost = ethers.BigNumber.from(mintQty).mul(await minterContr.publicSalePrice());

    await minterContr.connect(random).publicOrder(await random.getAddress(), mintQty, {value: totalCost});
        
    let balBefore = toBN(await deployer.getBalance());
    await minterContr.connect(deployer).withdraw(amt);
    let balAfter = await deployer.getBalance();

    let diff = balAfter.sub(balBefore);
    //console.log("Diff: ", ethers.utils.formatUnits(diff, unit = "ether"), "eth");
    expect(diff).to.be.above(amt.sub(toBN(10).pow(16)));

  });

});


});